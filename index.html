<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Спиральный фрактал</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            height: 100vh;
        }
        
        #fractalCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="fractalCanvas"></canvas>

    <script>
        const canvas = document.getElementById('fractalCanvas');
        const ctx = canvas.getContext('2d');
        
        let time = 0;
        let animationId = null;
        let colorCycleTime = 0;
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', resizeCanvas);
        resizeCanvas();
        
        // Цветовая схема для плавного перехода
        const colorPalette = [
            '#ff0000', // красный
            '#ff3300', // красно-оранжевый
            '#ff6600', // оранжевый
            '#ff9900', // светло-оранжевый
            '#ffcc00', // желто-оранжевый
            '#ffff00', // желтый
            '#ccff00', // желто-зеленый
            '#99ff00', // лаймовый
            '#66ff00', // зеленый
            '#00ff00', // ярко-зеленый
            '#00ff66', // зелено-голубой
            '#00ffcc', // бирюзовый
            '#00ffff', // голубой
            '#0099ff', // светло-синий
            '#0066ff', // синий
            '#3300ff', // фиолетово-синий
            '#6600ff', // фиолетовый
            '#9900ff', // пурпурный
            '#cc00ff', // розово-фиолетовый
            '#ff00ff', // розовый
            '#ff0099', // красно-розовый
            '#ff0066', // малиновый
            '#ff0033'  // темно-красный
        ];
        
        // Функция для получения текущего цвета на основе времени
        function getCurrentColor(time) {
            // Полный цикл смены цветов за 30 секунд
            const cycleDuration = 30; // секунды
            const progress = (time % cycleDuration) / cycleDuration;
            
            const totalColors = colorPalette.length;
            const colorIndex = progress * totalColors;
            const baseIndex = Math.floor(colorIndex) % totalColors;
            const nextIndex = (baseIndex + 1) % totalColors;
            const factor = colorIndex - baseIndex;
            
            return interpolateColor(colorPalette[baseIndex], colorPalette[nextIndex], factor);
        }
        
        function interpolateColor(color1, color2, factor) {
            const r1 = parseInt(color1.substring(1, 3), 16);
            const g1 = parseInt(color1.substring(3, 5), 16);
            const b1 = parseInt(color1.substring(5, 7), 16);
            
            const r2 = parseInt(color2.substring(1, 3), 16);
            const g2 = parseInt(color2.substring(3, 5), 16);
            const b2 = parseInt(color2.substring(5, 7), 16);
            
            const r = Math.round(r1 + (r2 - r1) * factor);
            const g = Math.round(g1 + (g2 - g1) * factor);
            const b = Math.round(b1 + (b2 - b1) * factor);
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        function getColorVariation(baseColor, variation) {
            const rgb = hexToRgb(baseColor);
            if (!rgb) return baseColor;
            
            const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
            hsl.h = (hsl.h + variation * 360) % 360;
            
            const newRgb = hslToRgb(hsl.h, hsl.s, hsl.l);
            return `rgb(${Math.round(newRgb.r)}, ${Math.round(newRgb.g)}, ${Math.round(newRgb.b)})`;
        }
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            
            return {
                h: h * 360,
                s: s * 100,
                l: l * 100
            };
        }
        
        function hslToRgb(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return {
                r: r * 255,
                g: g * 255,
                b: b * 255
            };
        }
        
        function drawSpiralFractal(timeValue) {
            // ВАЖНО: Используем ЧЁРНЫЙ фон с НЕПРОЗРАЧНОСТЬЮ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.07)'; // Полностью черный
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Получаем текущий основной цвет на основе времени
            const baseColor = getCurrentColor(colorCycleTime);
            
            for(let i = 0; i < 6; i++) {
                const angle = (i * Math.PI / 3) + time * 0.001;
                
                // Создаем небольшие вариации цвета для каждой спирали
                const hueVariation = i * 0.1;
                const spiralColor = getColorVariation(baseColor, hueVariation);
                
                drawSpiral(centerX, centerY, angle, 0.95, spiralColor, timeValue);
            }
        }
        
        function drawSpiral(x, y, startAngle, scale, color, timeValue) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            let radius = 5;
            let angle = startAngle;
            
            for(let i = 0; i < 150; i++) {
                const posX = x + Math.cos(angle) * radius;
                const posY = y + Math.sin(angle) * radius;
                
                if(i === 0) {
                    ctx.moveTo(posX, posY);
                } else {
                    ctx.lineTo(posX, posY);
                }
                
                radius *= 1.05;
                angle += 0.1 + Math.sin(timeValue * 0.002) * 0.05;
            }
            
            ctx.stroke();
        }
        
        function animate(timeValue) {
            time += 0.016;
            colorCycleTime += 0.016;
            
            drawSpiralFractal(timeValue);
            
            animationId = requestAnimationFrame(animate);
        }
        
        animate(0);
        
        window.addEventListener('beforeunload', () => {
            if(animationId) {
                cancelAnimationFrame(animationId);
            }
        });
    </script>
</body>
</html>
